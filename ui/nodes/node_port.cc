/****************************************************************************
**
* *Copyright (C) 2014
**
* *This file is generated by the Magus toolkit
**
* *THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* *"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* *LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* *A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* *OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* *SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* *LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* *DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* *THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* *(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* *OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#include "node_port.h"

#include "node_constants.h"
#include "node_node.h"

static constexpr auto NODE_PORT_PEN_SIZE = 1;

//****************************************************************************/
QtPort::QtPort(unsigned int portId,
               const QString &portName,
               QtPortType portType,
               QColor portColour,
               QColor connectionColour,
               QtPortShape portShape,
               Alignment alignment,
               qreal zoom,
               QGraphicsItem *parent)
    : QGraphicsPathItem(parent)
{
	m_port_id = portId;
	m_port_name = portName;
	m_port_type = portType;
	m_port_colour = portColour;
	m_connection_colour = connectionColour;
	m_port_shape = portShape;
	m_alignment = alignment;
	m_zoom = zoom;
	m_parent = parent;
	m_port_open = true;
	m_connection = nullptr;
	m_copy_of_port = 0;
	m_connection_is_base = false;

	/* Set default: Input and Output ports may only be connected to each other */
	if (m_port_type.m_port_type == NODE_PORT_TYPE_INPUT) {
		QtOutputPortType outputPortType;
		m_port_type.addPortTypeToConnectionPolicy(outputPortType);
	}
	else if (portType.m_port_type == NODE_PORT_TYPE_OUTPUT) {
		QtInputPortType inputPortType;
		m_port_type.addPortTypeToConnectionPolicy(inputPortType);
	}


	/* Create label */
	m_label = new QGraphicsTextItem(this);
	m_label->setPlainText(portName);

	QPen pen(portColour);
	pen.setWidth(m_zoom * NODE_PORT_PEN_SIZE);
	setPen(pen);
	redraw();
}

//****************************************************************************/
//****************************************************************************/
void QtPort::setPortOpen(bool open)
{
	m_port_open = open;
	if (!open) {
		setBrush(m_port_colour);
	}
	else {
		QColor col(QString("#000000ff"));
		setBrush(col);
	}
}

//****************************************************************************/
void QtPort::setNameColor(const QColor &color)
{
	m_label->setDefaultTextColor(color);
}

//****************************************************************************/
void QtPort::setZoom(qreal zoom)
{
	m_zoom = zoom;
}

//****************************************************************************/
void QtPort::redraw()
{
	m_font.setPointSize(m_zoom * NODE_PORT_FONT_SIZE);
	m_label->setFont(m_font);

	QPainterPath p;
	QPen pen(m_port_colour);
	pen.setWidth(m_zoom * NODE_PORT_PEN_SIZE);
	setPen(pen);
	qreal shapeSize = m_zoom * NODE_PORT_SHAPE_SIZE;

	switch (m_port_shape) {
		case PORT_SHAPE_CIRCLE:
		{
			p.addEllipse(-0.5f * shapeSize, -0.5f * shapeSize, shapeSize, shapeSize);
			setPath(p);
			break;
		}
		case PORT_SHAPE_SQUARE:
		{
			p.addRect(-0.5f * shapeSize, -0.5f * shapeSize, shapeSize, shapeSize);
			setPath(p);
			break;
		}
	}

	QPointF position = pos();
	setAlignedPos(position);
}

//****************************************************************************/
qreal QtPort::getNormalizedWidth()
{
	/* Set the fontsize of the text to zoom = 1 and get the boundingRect().width() of the text and the shape */
	m_font.setPointSize(NODE_PORT_FONT_SIZE);
	m_label->setFont(m_font);
	qreal width = m_label->boundingRect().width() + NODE_PORT_SHAPE_SIZE + NODE_PORT_WIDTH_MARGIN;
	m_font.setPointSize(m_zoom * NODE_PORT_FONT_SIZE);
	m_label->setFont(m_font);

	return width;
}

//****************************************************************************/
qreal QtPort::getNormalizedHeight()
{
	/* Set the fontsize of the text to zoom = 1 and get the boundingRect().heigth() of the text and the shape */
	m_font.setPointSize(NODE_PORT_FONT_SIZE);
	m_label->setFont(m_font);
	qreal height = m_label->boundingRect().height();

	if (height < NODE_PORT_SHAPE_SIZE) {
		height = NODE_PORT_SHAPE_SIZE; /* In case the text is smaller than the port shape */
	}

	m_font.setPointSize(m_zoom * NODE_PORT_FONT_SIZE);
	m_label->setFont(m_font);

	return height;
}

//****************************************************************************/
void QtPort::setAlignedPos(const QPointF &pos)
{
	if (m_alignment == ALIGNED_RIGHT) {
		m_label->setPos(-m_label->boundingRect().width() - m_zoom * NODE_PORT_WIDTH_MARGIN, -0.5 * m_label->boundingRect().height());
	}
	else {
		m_label->setPos(m_zoom * NODE_PORT_WIDTH_MARGIN, -0.5 * m_label->boundingRect().height());
	}

	setPos(pos);
}

//****************************************************************************/
void QtPort::setAlignedPos(qreal x, qreal y)
{
	setAlignedPos(QPointF(x, y));
}

//****************************************************************************/
QtConnection *QtPort::createConnection(QtConnection *targetConnection)
{
	if (targetConnection) {
		/* The port is not the base, but the target */
		m_connection = targetConnection;
		targetConnection->setTargetPort(this);
		m_connection_is_base = false;
	}
	else {
		/* The port is the base */
		/* Note, that adding the connection to the scene is done on a higher level */
		m_connection = new QtConnection(this); /* Don't make it a child of port, but do provide the port as a baseport */
		m_connection->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_CONNECTION));
		m_connection->setColor(m_connection_colour);
		m_connection_is_base = true;
	}

	setPortOpen(false);
	return m_connection;
}

//****************************************************************************/
void QtPort::setConnection(QtConnection *connection, bool base)
{
	m_connection = connection;

	if (base) {
		if (connection) {
			m_connection->setBasePort(this);
			setPortOpen(false);
		}
		else
			setPortOpen(true);

		m_connection_is_base = true;
	}
	else {
		if (connection) {
			m_connection->setTargetPort(this);
			setPortOpen(false);
		}
		else {
			setPortOpen(true);
		}

		m_connection_is_base = false;
	}
}

//****************************************************************************/
void QtPort::deleteConnection()
{
	if (m_connection) {
		QtPort *basePort = m_connection->getBasePort();
		QtPort *targetPort = m_connection->getTargetPort();

		if (m_connection_is_base) {
			/* Inform the target port */
			if (targetPort) {
				targetPort->informConnectionDeleted();
			}
		}
		else {
			/* 'This' port is the target port; call the base port to delete its connection */
			basePort->deleteConnection();
		}

		m_connection_is_base = false;
		delete m_connection;
		m_connection = nullptr;
		setPortOpen(true);
	}
}

//****************************************************************************/
void QtPort::informConnectionDeleted()
{
	setPortOpen(true);
	m_connection_is_base = false;
	m_connection = nullptr;
}

//****************************************************************************/
QtConnection *QtPort::getConnection() const
{
	return m_connection;
}

//****************************************************************************/
void QtPort::updateConnection(const QPointF &altTargetPos)
{
	if (m_connection) {
		m_connection->updatePath(altTargetPos);
	}
}

//****************************************************************************/
bool QtPort::isConnectionAllowed(QtPort *portToConnect)
{
	if (portToConnect) {
		QtPortType pt = portToConnect->getPortType();
		if (m_port_type.isConnectionAllowed(pt))
			return true;
	}

	return false;
}

//****************************************************************************/
bool QtPort::isBasePort()
{
	if (m_connection) {
		return (this == m_connection->getBasePort());
	}

	return false;
}
\
//****************************************************************************/
bool QtPort::isTargetPort()
{
	if (m_connection) {
		return (this == m_connection->getTargetPort());
	}

	return false;
}

//****************************************************************************/
void QtPort::collapse()
{
	setVisible(false);
	m_original_pos = pos() / m_zoom;
	qreal y = 0.5 * parentItem()->boundingRect().height();
	setAlignedPos(m_zoom * m_original_pos.x(), y);

	if (m_connection) {
		m_connection->setZValue(-1);
		m_connection->updatePath(pos());
	}
}

//****************************************************************************/
void QtPort::expand()
{
	setVisible(true);
	setAlignedPos(m_zoom * m_original_pos);

	if (m_connection) {
		m_connection->setZValue(1);
		m_connection->updatePath(pos());
	}
}

//****************************************************************************/
void QtPort::setCopyOfPort(QtPort *port)
{
	m_copy_of_port = port;
}
