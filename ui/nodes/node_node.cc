/****************************************************************************
**
* *Copyright (C) 2014
**
* *This file is generated by the Magus toolkit
**
* *THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* *"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* *LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* *A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* *OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* *SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* *LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* *DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* *THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* *(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* *OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#include "node_node.h"

#include <kamikaze/nodes.h>

#include "node_constants.h"
#include "node_port.h"
#include "node_editorwidget.h"

static constexpr auto NODE_HEADER_TITLE_FONT_SIZE = 12;
static constexpr auto NODE_HEADER_ICON_SIZE = 20.0f;
static constexpr auto NODE_WIDTH = 200.0f;
static constexpr auto NODE_HEADER_HEIGHT = 30.0f;
static constexpr auto NODE_BODY_HEIGHT = 32.0f;

static constexpr auto NODE_PEN_WIDTH_UNSELECTED = 1;
static constexpr auto NODE_PEN_WIDTH_SELECTED = 1;

static constexpr auto NODE_IMAGE_FRACTION = 0.95f;

QtNode::QtNode(const QString &title, QGraphicsItem *parent)
    : QGraphicsPathItem(parent)
{
	/* Header */
	m_zoom = 1.0f;
	m_active_connection = 0;
	m_data = nullptr;
	m_pixmap_item = new QGraphicsPixmapItem(this);
	m_image_set = false;
	m_auto_size = true;
	m_icon_size = m_zoom * NODE_HEADER_ICON_SIZE;
	m_normalized_width = NODE_WIDTH;
	m_normalized_body_height = NODE_BODY_HEIGHT;
	m_width = m_zoom * m_normalized_width;
	m_header_height = m_zoom * NODE_HEADER_HEIGHT;
	m_body_height = m_zoom * m_normalized_body_height;
	m_port_name_color = Qt::white;

	QLinearGradient linearGrad(0, 0, 300, NODE_HEADER_HEIGHT);
	linearGrad.setColorAt(0, QColor("#945555"));
	linearGrad.setColorAt(0.2, QColor("#3e3e3e"));
	m_header_brush = QBrush(linearGrad);
	setFlag(QGraphicsItem::ItemIsMovable);
	setFlag(QGraphicsItem::ItemIsSelectable);

	/* Add icons to the header */
	m_header_title_icon = new QGraphicsPixmapItem(this); /* MUST be a child of QtNode */
	m_action_1_icon = new QGraphicsPixmapItem(this); /* MUST be a child of QtNode */
	m_action_2_icon = new QGraphicsPixmapItem(this); /* MUST be a child of QtNode */
	m_header_title_icon->setScale(0.0f);
	m_action_1_icon->setScale(0.0f);
	m_action_2_icon->setScale(0.0f);
	m_header_title_icon->setVisible(false);
	m_action_1_icon->setVisible(false);
	m_action_2_icon->setVisible(false);

	/* Body */
	m_body = new QGraphicsPathItem(this); /* MUST be a child of QtNode */
	m_body->setBrush(QColor("#3e3e3e"));
	m_body->setFlag(QGraphicsItem::ItemStacksBehindParent);

	/* Generic */
	setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_NODE));
	m_header_title_icon->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_HEADER_ICON));
	m_action_1_icon->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_ACTION_1_ICON));
	m_action_2_icon->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_ACTION_2_ICON));
	m_body->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_NODE_BODY));

	/* Set title */
	m_title = title;
	m_title_label = new QGraphicsTextItem(this);
	m_title_label->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_HEADER_TITLE));
	m_title_label->setPlainText(m_title);
	m_font_header.setPointSize(m_zoom * NODE_HEADER_TITLE_FONT_SIZE);
	m_title_label->setFont(m_font_header);
	m_title_alignment = ALIGNED_CENTER;
	adjustWidthForTitle();
}

void QtNode::setAutoSize(bool autoSize)
{
	m_auto_size = autoSize;
}

bool QtNode::isAutoSize() const
{
	return m_auto_size;
}

void QtNode::setWidth(qreal width)
{
	m_width = width;
	redraw();
}

void QtNode::setHeaderHeight(qreal headerHeight)
{
	m_header_height = headerHeight;
	redraw();
}

void QtNode::setBodyHeight(qreal bodyHeight)
{
	m_body_height = bodyHeight;
	redraw();
}

qreal QtNode::getWidth() const
{
	return m_width;
}

qreal QtNode::getHeigth() const
{
	return (m_body->isVisible()) ? m_body_height : m_header_height;
}

/* Adjust the width of the node, depending on total width of the title and the
 * icons. Calculate using zoom factor 1.0 */
void QtNode::adjustWidthForTitle()
{
	auto offset = 0.5f * (NODE_HEADER_HEIGHT - NODE_HEADER_ICON_SIZE);
	m_font_header.setPointSize(NODE_HEADER_TITLE_FONT_SIZE);
	m_title_label->setFont(m_font_header);
	//qreal unzoomedTitleWidth = mTitleLabel->boundingRect().width();
	auto spaceLeft = m_normalized_width;

	if (m_header_title_icon->isVisible()) {
		spaceLeft -= NODE_HEADER_ICON_SIZE;
		spaceLeft -= offset;
	}

	if (m_action_1_icon->isVisible()) {
		spaceLeft -= NODE_HEADER_ICON_SIZE;
		spaceLeft -= offset;
	}

	if (m_action_2_icon->isVisible()) {
		spaceLeft -= NODE_HEADER_ICON_SIZE;
		spaceLeft -= offset;
	}

	if (m_title_label->boundingRect().width() > spaceLeft) {
		m_normalized_width += m_title_label->boundingRect().width() - spaceLeft;
	}

	/* Set values to original zoom factor */
	m_font_header.setPointSize(m_zoom * NODE_HEADER_TITLE_FONT_SIZE);
	m_title_label->setFont(m_font_header);
	m_width = m_zoom * m_normalized_width;
	redraw();
}

void QtNode::redraw()
{
	/* Redraw the node */
	auto halfWidth = 0.5f * m_width;
	auto offset = 0.5f * (m_header_height - m_icon_size);

	QPainterPath p;
	p.addRoundedRect(-halfWidth, 0, m_width, m_header_height, m_zoom * 4, m_zoom * 5);
	setPath(p);

	QPainterPath bodyPath;
	bodyPath.addRoundedRect(-halfWidth, 0, m_width, m_body_height, m_zoom * 4, m_zoom * 5);
	m_body->setPath(bodyPath);

	m_font_header.setPointSize(m_zoom * NODE_HEADER_TITLE_FONT_SIZE);
	m_title_label->setFont(m_font_header);

	if (m_header_title_icon->isVisible()) {
		/* Scale may only be set if visible */
		m_header_title_icon->setScale(m_icon_size/m_header_title_icon->pixmap().width());
	}

	if (m_action_1_icon->isVisible()) {
		/* Scale may only be set if visible */
		m_action_1_icon->setScale(m_icon_size/m_action_1_icon->pixmap().width());
	}

	if (m_action_2_icon->isVisible()) {
		/* Scale may only be set if visible */
		m_action_2_icon->setScale(m_icon_size/m_action_2_icon->pixmap().width());
	}

	m_header_title_icon->setPos(-halfWidth + offset, offset);
	m_action_1_icon->setPos(halfWidth - 2 * (m_icon_size + offset), offset);
	m_action_2_icon->setPos(halfWidth - (m_icon_size + offset), offset);
	setTitlePosition();

	/* Redraw image */
	auto height = NODE_BODY_HEIGHT;

	if (m_image_set) {
		auto scale = NODE_IMAGE_FRACTION * (m_width / m_image.width());

		if (m_pixmap_item->isVisible()) {
			/* Scale may only be set if visible */
			m_pixmap_item->setScale(scale);
		}

		m_pixmap_item->setPos(-0.5 * NODE_IMAGE_FRACTION * m_width, m_zoom * height);
		height = height + NODE_IMAGE_FRACTION * m_normalized_width;
	}

	/* Redraw ports */
	for (QtPort *port : m_port_list) {
		port->redraw();

		if (port->isVisible()) {
			/* This is in case the node is not collapsed */
			height += NODE_PORT_HEIGHT_MARGIN_FACTOR * port->getNormalizedHeight();
			setPortAlignedPos(port, m_zoom * height);
		}
		else {
			/* This is in case the node (and its ports) is collapsed; the port's
			 * height must be on the correct y-position (on the header), so the
			 * connections also remain on that position. */
			height = NODE_PORT_HEIGHT_MARGIN_FACTOR * port->getNormalizedHeight();
			setPortAlignedPos(port, m_zoom * height);
		}
	}
}

void QtNode::setZoom(qreal zoom)
{
	m_zoom = zoom;
	m_icon_size = m_zoom * NODE_HEADER_ICON_SIZE;
	m_width = m_zoom * m_normalized_width;
	m_header_height = m_zoom * NODE_HEADER_HEIGHT;
	m_body_height = m_zoom * m_normalized_body_height;

	/* Set zoom for all ports */
	for (QtPort *port : m_port_list) {
		port->setZoom(m_zoom);
	}

	redraw();
}

void QtNode::setHeaderColor(const QColor &color)
{
	QLinearGradient linearGrad(0, 0, 300, NODE_HEADER_HEIGHT);
	linearGrad.setColorAt(0, color);
	linearGrad.setColorAt(0.2, QColor("#3e3e3e"));
	m_header_brush = QBrush(linearGrad);
}

void QtNode::setTitleColor(const QColor &color)
{
	m_title_label->setDefaultTextColor(color);
}

void QtNode::setPortNameColor(const QColor &color)
{
	m_port_name_color = color;

	for (QtPort *port : m_port_list) {
		port->setNameColor(color);
	}
}

void QtNode::alignTitle(Alignment alignment)
{
	m_title_alignment = alignment;
	setTitlePosition();
}

void QtNode::setTitlePosition()
{
	auto halfWidth = 0.5f * m_width;
	auto offset = 0.5f * (m_header_height - m_icon_size);

	switch (m_title_alignment) {
		case ALIGNED_LEFT:
		{
			if (m_header_title_icon->isVisible()) {
				/* Position it right to the icon */
				m_title_label->setPos(-halfWidth + m_icon_size + offset,
				                    0.5 * (m_header_height - m_title_label->boundingRect().height()));
			}
			else {
				/* Position it where the icon should be */
				m_title_label->setPos(-halfWidth + offset,
				                    0.5 * (m_header_height - m_title_label->boundingRect().height()));
			}

			break;
		}
		case ALIGNED_RIGHT:
		{
			if (m_action_1_icon->isVisible()) {
				/* Position it left from action1 icon */
				m_title_label->setPos(halfWidth - 2 * (offset + m_icon_size) - m_title_label->boundingRect().width(),
				                    0.5 * (m_header_height - m_title_label->boundingRect().height()));
			}
			else {
				if (m_action_2_icon->isVisible()) {
					/* Position it left from action2 icon */
					m_title_label->setPos(halfWidth - offset - m_icon_size - m_title_label->boundingRect().width(),
					                    0.5 * (m_header_height - m_title_label->boundingRect().height()));
				}
				else {
					/* Position it right */
					m_title_label->setPos(halfWidth - offset - m_title_label->boundingRect().width(),
					                    0.5 * (m_header_height - m_title_label->boundingRect().height()));
				}
			}

			break;
		}
		case ALIGNED_CENTER:
		{
			m_title_label->setPos(-0.5 * m_title_label->boundingRect().width(),
			                    0.5 * (m_header_height - m_title_label->boundingRect().height()));
			break;
		}
	}
}

void QtNode::_setEditor(QtNodeEditor *editor)
{
	m_editor = editor;
}

void QtNode::_setScene(QGraphicsScene *scene)
{
	m_scene = scene;
}

void QtNode::setHeaderTitleIcon(const QString &fileNameIcon)
{
	QPixmap pixmap(fileNameIcon);
	m_header_title_icon->setPixmap(pixmap);

	if (pixmap.width() != 0) {
		m_header_title_icon->setScale(m_icon_size/pixmap.width());
		m_header_title_icon->setVisible(true);
	}

	adjustWidthForTitle();
}

void QtNode::setAction1Icon(const QString &fileNameIcon)
{
	QPixmap pixmap (fileNameIcon);
	m_action_1_icon->setPixmap(pixmap);

	if (pixmap.width() != 0) {
		m_action_1_icon->setScale(m_icon_size/pixmap.width());
		m_action_1_icon->setVisible(true);
	}

	adjustWidthForTitle();
}

void QtNode::setAction2Icon(const QString &fileNameIcon)
{
	QPixmap pixmap (fileNameIcon);
	m_action_2_icon->setPixmap(pixmap);

	if (pixmap.width() != 0) {
		m_action_2_icon->setScale(m_icon_size/pixmap.width());
		m_action_2_icon->setVisible(true);
	}

	adjustWidthForTitle();
}

void QtNode::setIconSize(qreal size)
{
	m_icon_size = size;
}

bool QtNode::mouseLeftClickHandler(QGraphicsSceneMouseEvent *mouseEvent,
                                   QGraphicsItem *item,
                                   unsigned int action,
                                   QtConnection *activeConnection)
{
	int type = 0;

	if (item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).isValid()) {
		type = item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).toInt();
	}

	switch (type) {
		case NODE_VALUE_TYPE_PORT:
		{
			QtPort *port = static_cast<QtPort*>(item);

			/* Check wether the port is available; if not, return false */
			if (!port->isPortOpen()){
				return false;
			}

			if (action == NODE_ACTION_BASE) {
				/* Create a new connection; this node is the baseNode (with the base port) */
				createActiveConnection(port, mouseEvent->scenePos());
			}
			else if (action == NODE_ACTION_TARGET && activeConnection) {
				/* Check wether the connection is allowed; if not, return false */
				/* This node is the target node (with the target port) */
				QtPort *basePort = activeConnection->getBasePort();

				if (!port->isConnectionAllowed(basePort)) {
					return false;
				}

				/* Finalize the connection; this node is the targetNode */
				if (activeConnection) {
					port->createConnection(activeConnection);

					/* used to be Q_EMIT, but does not work for some reason */
					m_editor->connectionEstablished(this, port, activeConnection);
				}
			}

			break;
		}
		case NODE_VALUE_TYPE_ACTION_1_ICON:
			Q_EMIT action1Clicked(this);
			mouseLeftClickAction1ButtonHandler(mouseEvent, item);
			break;

		case NODE_VALUE_TYPE_ACTION_2_ICON:
			Q_EMIT action2Clicked(this);
			mouseLeftClickAction2ButtonHandler(mouseEvent, item);
			break;
	}

	return true;
}

void QtNode::mouseLeftClickAction1ButtonHandler(QGraphicsSceneMouseEvent *mouseEvent, QGraphicsItem *item)
{
	Q_UNUSED(mouseEvent);
	Q_UNUSED(item);

	return ((m_body->isVisible()) ? collapse() : expand());
}

void QtNode::mouseLeftClickAction2ButtonHandler(QGraphicsSceneMouseEvent *mouseEvent, QGraphicsItem *item)
{
	Q_UNUSED(mouseEvent);
	Q_UNUSED(item);

	/* Delegate to the editor */
	m_editor->removeNode(this);
}

bool QtNode::mouseRightClickHandler(QGraphicsSceneMouseEvent *mouseEvent,
                                    QGraphicsItem *item,
                                    unsigned int action,
                                    QtConnection *activeConnection)
{
	Q_UNUSED(mouseEvent);
	Q_UNUSED(item);
	Q_UNUSED(action);
	Q_UNUSED(activeConnection);
	/* TODO */
	return true;
}

bool QtNode::mouseDoubleClickHandler(QGraphicsSceneMouseEvent *mouseEvent, QGraphicsItem *item)
{
	Q_UNUSED(mouseEvent);
	Q_UNUSED(item);
	/* TODO */
	return true;
}

bool QtNode::mouseMoveHandler(QGraphicsSceneMouseEvent *mouseEvent, QGraphicsItem *item)
{
	Q_UNUSED(item);

	if (m_active_connection) {
		/* There is an active connection, so the connection is dragged with the mouse cursor */
		m_active_connection->updatePath(mouseEvent->scenePos());
	}

	return true;
}

void QtNode::collapse()
{
	/* Set visibility of the image */
	m_pixmap_item->setVisible(false);

	/* Set visibility of the body */
	m_body->setVisible(false);

	/* Set visibility of the ports */
	for (QtPort *port : m_port_list) {
		if (port->isVisible()) {
			port->collapse();
		}
	}
}

void QtNode::expand()
{
	/* Set visibility of the image */
	m_pixmap_item->setVisible(true);

	/* Set visibility of the body */
	m_body->setVisible(true);

	/* Set visibility of the ports */
	for (QtPort *port : m_port_list) {
		if (!port->isVisible()) {
			port->expand();
		}
	}

	if (m_image_set) {
		/* Needed to scale the image (image does not scale if not visible) */
		redraw();
	}
}

void QtNode::createActiveConnection(QtPort *port, QPointF pos)
{
	m_active_connection = port->createConnection();
	m_scene->addItem(m_active_connection);
	m_active_connection->updatePath(pos);
	Q_EMIT connectionStarted(this, port, m_active_connection);
}

void QtNode::deleteActiveConnection()
{
	if (m_active_connection) {
		QtPort *port = m_active_connection->getBasePort();
		m_scene->removeItem(m_active_connection);
		port->deleteConnection();
		m_active_connection = nullptr;
	}
}

void QtNode::deleteAllConnections()
{
	for (QtPort *port : m_port_list) {
		QtConnection *connection = port->getConnection();
		m_scene->removeItem(connection);
		port->deleteConnection();
	}
}

void QtNode::selectConnections(bool selected)
{
	for (QtPort *port : m_port_list) {
		QtConnection *connection = port->getConnection();
		if (connection && (connection != m_active_connection)) {
			connection->setSelected(selected);
		}
	}
}

void QtNode::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
	Q_UNUSED(option)
	Q_UNUSED(widget)

	/* Paint header */
	painter->setBackgroundMode(Qt::OpaqueMode);
	painter->setBrush(m_header_brush);

	if (isSelected()) {
		m_pen.setColor("#cc7800");
		m_pen.setWidth(m_zoom * NODE_PEN_WIDTH_SELECTED);
	}
	else {
		m_pen.setColor(Qt::black);
		m_pen.setWidth(m_zoom * NODE_PEN_WIDTH_UNSELECTED);
	}

	painter->setPen(m_pen);
	m_body->setPen(m_pen);
	painter->drawPath(path());

	/* Only update the connection if it not the active one */
	for (QtPort *port : m_port_list) {
		if (port->getConnection() != m_active_connection)
			port->updateConnection();
	}
}

void QtNode::setNode(Node *node)
{
	m_data = node;
	int num_ports = 0;

	QtInputPortType inputPortType;
	QtOutputPortType outputPortType;

	for (const auto &input : node->inputs()) {
		createPort(num_ports++,
		           input->name.c_str(),
		           inputPortType,
		           QColor(95, 95, 95),
		           PORT_SHAPE_CIRCLE,
		           ALIGNED_LEFT,
		           QColor(95, 95, 95));
	}

	for (const auto &output : node->outputs()) {
		createPort(num_ports++,
		           output->name.c_str(),
		           outputPortType,
		           QColor(95, 95, 95),
		           PORT_SHAPE_CIRCLE,
		           ALIGNED_RIGHT,
		           QColor(95, 95, 95));
	}
}

Node *QtNode::getNode() const
{
	return m_data;
}

QtPort *QtNode::createPort(unsigned int portId,
                           const QString &portName,
                           QtPortType portType,
                           QColor portColour,
                           QtPortShape portShape,
                           Alignment alignement,
                           QColor connectionColor)
{
	QtPort *port = new QtPort(portId, portName, portType, portColour, connectionColor, portShape, alignement, m_zoom, this);
	port->setNameColor(m_port_name_color);
	port->setData(NODE_KEY_GRAPHIC_ITEM_TYPE, QVariant(NODE_VALUE_TYPE_PORT));
	m_port_list.append(port);

	if (m_auto_size) {
		m_normalized_body_height += NODE_PORT_HEIGHT_MARGIN_FACTOR * port->getNormalizedHeight();
		m_body_height = m_zoom * m_normalized_body_height;

		/* Adjust width of the node (if needed) to fit the port */
		qreal normalized = port->getNormalizedWidth() + 2.5f * NODE_PORT_OFFSET;
		if (normalized > m_normalized_width)
			m_normalized_width = normalized;
		m_width = m_zoom * m_normalized_width;
	}

	setPortAlignedPos(port, m_body_height);
	redraw();

	return port;
}

void QtNode::setImage(const QString &fileNameImage)
{
	m_image = QPixmap(fileNameImage);
	setImage(m_image);
}

void QtNode::setImage(const QPixmap &pixMap)
{
	m_image = pixMap;
	m_pixmap_item->setPixmap(m_image);

	if (m_auto_size) {
		if (!m_image_set) {
			m_normalized_body_height += NODE_IMAGE_FRACTION * m_normalized_width;
			m_body_height = m_zoom * m_normalized_body_height;
		}
	}

	m_image_set = true;
	redraw();
}

void QtNode::setPortAlignedPos(QtPort *port, qreal height)
{
	/* Position */
	auto halfWidth = 0.5f * m_width;
	auto offset = m_zoom * NODE_PORT_OFFSET;
	auto portWidth = m_zoom * port->getNormalizedWidth();

	switch (port->getAlignment()) {
		case ALIGNED_LEFT:
			port->setAlignedPos(-halfWidth + offset, height - offset);
			break;
		case ALIGNED_RIGHT:
			port->setAlignedPos(halfWidth - offset, height - offset);
			break;
		case ALIGNED_CENTER:
			port->setAlignedPos(-0.5 * portWidth, height - offset);
			break;
	}
}

void QtNode::_emitNodeSelected()
{
	Q_EMIT nodeSelected(this);
}

void QtNode::_emitConnectionDeleted(QtPort *port)
{
	Q_EMIT connectionDeleted(this, port);
}

void QtNode::setParentItem(QGraphicsItem *parent)
{
	m_original_parent = parentItem();
	QGraphicsPathItem::setParentItem(parent);
}

void QtNode::_restoreOriginalParentItem()
{
	setParentItem(m_original_parent);
}

void QtNode::_prepareDelete()
{
	deleteAllConnections();
}

QtPort *QtNode::getPort(const QString &portName)
{
	auto iter = std::find_if(m_port_list.begin(), m_port_list.end(), [&](QtPort *port)
	{
		return port->getPortName() == portName;
	});

	if (iter != m_port_list.end()) {
		return *iter;
	}

	return nullptr;
}

QtPort *QtNode::getPort(unsigned int portId)
{
	auto iter = std::find_if(m_port_list.begin(), m_port_list.end(), [&](QtPort *port)
	{
		return port->getPortId() == portId;
	});

	if (iter != m_port_list.end()) {
		return *iter;
	}

	return nullptr;
}

QtPort *QtNode::getPort(const QString &portName, unsigned int occurence)
{
	/* 1. Run through all of the ports in this node
	 * 2. Return the n-th occurence of the port with the same name */
	unsigned int count = 1;
	for (QtPort *port : m_port_list) {
		if (port->getPortName() == portName) {
			if (count == occurence)
				return port;

			++count;
		}
	}

	return nullptr;
}

QVector<QtPort *> QtNode::getPorts()
{
	return m_port_list;
}

/* 1. Run through all of the ports in this node
 * 2. Append all the ports with the same name to a vector
 * 3. Return the vector */
QVector<QtPort *> QtNode::getPorts(const QString &portName)
{
	QVector<QtPort *> ports;
	ports.reserve(m_port_list.size());

	std::copy_if(m_port_list.begin(), m_port_list.end(), ports.begin(), [&](QtPort *port)
	{
		return port->getPortName() == portName;
	});

	return ports;
}

/* 1. Run through all of the ports in this node
 * 2. Return true if a port in this list is the same as the port passed as an argument */
bool QtNode::isPortOfThisNode(QtPort *port)
{
	auto iter = std::find(m_port_list.begin(), m_port_list.end(), port);
	return (iter != m_port_list.end());
}

/* 1. Run through all of the ports in this node
 * 2. Return true if there is a port in this list with the same portId */
bool QtNode::isPortOfThisNode(unsigned int portId)
{
	auto iter = std::find_if(m_port_list.begin(), m_port_list.end(), [&](QtPort *port)
	{
		return port->getPortId() == portId;
	});

	return (iter != m_port_list.end());
}

bool QtNode::isPortOfThisNode(const QString &portName)
{
	return getPort(portName);
}

bool QtNode::isConnectionConnectedToThisNode(QtConnection *connection)
{
	for (QtPort *port : m_port_list) {
		if (connection == port->getConnection()) {
			return true;
		}
	}

	return false;
}

/* 1. Get the port that is connected to the given port (of this node)
 * 2. If there is a connected port, return its parent node */
QtNode *QtNode::getNodeConnectedToPort(QtPort *port)
{
	QtNode *node = nullptr;
	QtPort *connectedPort = getPortConnectedToPort(port);

	if (connectedPort != nullptr) {
		node = static_cast<QtNode *>(connectedPort->parentItem());
	}

	return node;
}

/* 1. Get the port that is connected to the given port (of this node)
 * 2. If there is a connected port, return its parent node */
QtNode *QtNode::getNodeConnectedToPort(unsigned int portId)
{
	QtNode *node = nullptr;
	QtPort *connectedPort = getPortConnectedToPort(portId);

	if (connectedPort != nullptr) {
		node = static_cast<QtNode *>(connectedPort->parentItem());
	}

	return node;
}

/* 1. Get the port that is connected to the given port (of this node)
 * 2. If there is a connected port, return its parent node */
QtNode *QtNode::getNodeConnectedToPort(const QString &portName)
{
	QtNode *node = nullptr;
	QtPort *connectedPort = getPortConnectedToPort(portName);

	if (connectedPort != nullptr) {
		node = static_cast<QtNode *>(connectedPort->parentItem());
	}

	return node;
}

/* 1. Get the n-th occurence of the port that is connected with the port of this node
 * 2. Return its parent node */
QtNode *QtNode::getNodeConnectedToPort(const QString &portName, unsigned int occurence)
{
	QtNode *node = nullptr;
	QtPort *connectedPort = getPortConnectedToPort(portName, occurence);

	if (connectedPort != nullptr) {
		node = static_cast<QtNode *>(connectedPort->parentItem());
	}

	return node;
}

/* 1. Get all ports that are connected to the ports (with the same name) of this node
 * 2. Append their parent nodes to the vector */
QVector<QtNode *> QtNode::getNodesConnectedToPorts(const QString &portName)
{
	QVector<QtNode*> connectedNodes;
	QVector<QtPort*> connectedPorts = getPortsConnectedToPorts (portName);

	for (QtPort *connectPort : connectedPorts) {
		connectedNodes.append(static_cast<QtNode *>(connectPort->parentItem()));
	}

	return connectedNodes;
}

QtPort *QtNode::getCheckedPortConnectedToPort(QtPort *port)
{
	/* Assume that the port is part of 'this' node */
	QtConnection *connection = port->getConnection();

	if (!connection) {
		return nullptr;
	}

	/* There is a connection; determine whether it is a finalished (established) connection */
	/* Both ports must exist */
	QtPort *basePort = connection->getBasePort();

	if (!basePort) {
		return nullptr;
	}

	QtPort *targetPort = connection->getTargetPort();

	if (!targetPort) {
		return nullptr;
	}

	if (port == basePort) {
		/* The port of 'this' node is the base port; use the target port */
		return targetPort;
	}
	else if (port == targetPort) {
		/* The port of 'this' node is the target port; use the base port */
		return basePort;
	}

	return nullptr;
}

QtPort *QtNode::getPortConnectedToPort(QtPort *port)
{
	/* First check whether the port is part of this node */
	if (!isPortOfThisNode(port)) {
		return nullptr;
	}

	return getCheckedPortConnectedToPort(port);
}

QtPort *QtNode::getPortConnectedToPort(unsigned int portId)
{
	QtPort *port = getPort(portId);

	if (!port) {
		return nullptr;
	}

	return getCheckedPortConnectedToPort(port);
}

QtPort *QtNode::getPortConnectedToPort(const QString &portName)
{
	QtPort *port = getPort(portName);

	if (!port) {
		return nullptr;
	}

	return getCheckedPortConnectedToPort(port);
}

QtPort *QtNode::getPortConnectedToPort(const QString &portName, unsigned int occurence)
{
	QtPort *port = getPort(portName, occurence);

	if (!port) {
		return nullptr;
	}

	return getCheckedPortConnectedToPort(port);
}

/* 1. Get the ports of this node with the same name.
 * 2. Get for each port the connected port */
QVector<QtPort*> QtNode::getPortsConnectedToPorts(const QString &portName)
{
	QVector<QtPort*> ports = getPorts(portName);
	QVector<QtPort*> connectedPorts;

	for (QtPort *port : ports) {
		connectedPorts.append(getCheckedPortConnectedToPort(port));
	}

	return connectedPorts;
}

void QtNode::setVisible(bool visible)
{
	/* Also make the connected nodes visible/invisible */
	for (QtPort *port : m_port_list) {
		if (port->getConnection()) {
			port->getConnection()->setVisible(visible);
		}
	}

	QGraphicsPathItem::setVisible(visible);
}
