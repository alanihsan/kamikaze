/****************************************************************************
**
* *Copyright (C) 2014
**
* *This file is generated by the Magus toolkit
**
* *THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
* *"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* *LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* *A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
* *OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* *SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* *LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* *DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* *THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* *(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* *OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#include "node_editorwidget.h"

#include <QGuiApplication>
#include <QVBoxLayout>

#include "node_compound.h"
#include "node_connection.h"
#include "node_node.h"
#include "node_port.h"
#include "node_scene.h"

static constexpr auto NODE_HEADER_COMPOUND_ICON = "../common/icons/compound.png";
static constexpr auto NODE_HEADER_ACTION1_ICON = "../common/icons/minmax.png";
static constexpr auto NODE_HEADER_ACTION2_ICON = "../common/icons/close.png";

static constexpr auto NODE_ACTION_DELETE = "Delete selected items";
static constexpr auto NODE_ACTION_CENTER = "Center";
static constexpr auto NODE_ACTION_SELECTED_TO_COMPOUND = "Create compound from selected items";
static constexpr auto NODE_ACTION_ZOOM = "Zoom (%)";
static constexpr auto NODE_ACTION_ZOOM_10 = "10%";
static constexpr auto NODE_ACTION_ZOOM_25 = "25%";
static constexpr auto NODE_ACTION_ZOOM_50 = "50%";
static constexpr auto NODE_ACTION_ZOOM_75 = "75%";
static constexpr auto NODE_ACTION_ZOOM_90 = "90%";
static constexpr auto NODE_ACTION_ZOOM_100 = "100%";
static constexpr auto NODE_ACTION_ZOOM_150 = "150%";
static constexpr auto NODE_ACTION_ZOOM_200 = "200%";
static constexpr auto NODE_ACTION_ZOOM_250 = "250%";
static constexpr auto NODE_ACTION_ZOOM_300 = "300%";
static constexpr auto NODE_ACTION_COLLAPSE_ALL = "Collapse all nodes";
static constexpr auto NODE_ACTION_EXPAND_ALL = "Expand all nodes";
static constexpr auto NODE_ENTER_OBJECT = "Enter object";
static constexpr auto NODE_EXIT_OBJECT = "Exit object";
static constexpr auto NODE_ACTION_EXPAND_COMPOUNDS = "Expand compounds";
static constexpr auto NODE_ACTION_FISHEY_VIEW = "Fisheye view";
static constexpr auto NODE_ACTION_FISHEYE_DISABLED = "Disabled";
static constexpr auto NODE_ACTION_FISHEYE_NORMAL = "Normal";
static constexpr auto NODE_ACTION_FISHEYE_NORMAL_SUBTLE = "Normal (subtle)";
static constexpr auto NODE_ACTION_FISHEYE_LARGE = "Large";
static constexpr auto NODE_ACTION_FISHEYE_LARGE_SUBTLE = "Large (subtle)";

//****************************************************************************/
QtNodeEditor::QtNodeEditor(QWidget *parent)
    : QWidget(parent)
{
	QVBoxLayout *mainLayout = new QVBoxLayout;
	m_view = new QGraphicsView(this);

	m_scene_scene = new QtNodeGraphicsScene();
	m_scene_scene->installEventFilter(this);
	m_current_scene = m_scene_scene;

	m_view->setScene(m_current_scene);

	m_view->setRenderHint(QPainter::Antialiasing, true);
	m_view->setInteractive(true);
	m_view->setMouseTracking(true);
	m_view->setBackgroundBrush(QBrush(QColor(127, 127, 127)));
	mainLayout->addWidget(m_view);
	m_last_removed_node = nullptr;
	m_rubber_band = nullptr;
	m_zoom = 1.0f;
	m_fisheye_view_enabled = false;
	m_fisheye_max_zoom = 1.0f;
	m_fisheye_steps = 5;
	m_header_title_icon = NODE_HEADER_COMPOUND_ICON;
	m_action_1_icon = NODE_HEADER_ACTION1_ICON;
	m_action_2_icon = NODE_HEADER_ACTION2_ICON;
	m_compound_node_dropped = nullptr;
	m_rubberband_selection = false;
	m_context_menu_enabled = true;
	m_context_menu = new QMenu(this);
	m_context_menu->addAction(new QAction(NODE_ACTION_DELETE, this));
	m_context_menu->addAction(new QAction(NODE_ACTION_CENTER, this));
	m_zoom_sub_menu = m_context_menu->addMenu(NODE_ACTION_ZOOM);
	QAction *action;
	QActionGroup actionGroupZoom(m_zoom_sub_menu);
	actionGroupZoom.setExclusive(true);
	action = new QAction(NODE_ACTION_ZOOM_10, this);
	action->setCheckable(true);
	actionGroupZoom.addAction(action);
	action = new QAction(NODE_ACTION_ZOOM_25, this);
	action->setCheckable(true);
	actionGroupZoom.addAction(action);
	action = new QAction(NODE_ACTION_ZOOM_50, this);
	action->setCheckable(true);
	actionGroupZoom.addAction(action);
	action = new QAction(NODE_ACTION_ZOOM_75, this);
	action->setCheckable(true);
	actionGroupZoom.addAction(action);
	action = new QAction(NODE_ACTION_ZOOM_90, this);
	action->setCheckable(true);
	actionGroupZoom.addAction(action);
	action = new QAction(NODE_ACTION_ZOOM_100, this);
	action->setCheckable(true);
	action->setChecked(true);
	actionGroupZoom.addAction(action);
	action = new QAction(NODE_ACTION_ZOOM_150, this);
	action->setCheckable(true);
	actionGroupZoom.addAction(action);
	action = new QAction(NODE_ACTION_ZOOM_200, this);
	action->setCheckable(true);
	actionGroupZoom.addAction(action);
	action = new QAction(NODE_ACTION_ZOOM_250, this);
	action->setCheckable(true);
	actionGroupZoom.addAction(action);
	action = new QAction(NODE_ACTION_ZOOM_300, this);
	action->setCheckable(true);
	actionGroupZoom.addAction(action);
	m_zoom_sub_menu->addActions(actionGroupZoom.actions());

	m_fisheye_view_sub_menu = m_context_menu->addMenu(NODE_ACTION_FISHEY_VIEW);
	QActionGroup actionGroupFisheye(m_fisheye_view_sub_menu);
	actionGroupFisheye.setExclusive(true);
	action = new QAction(NODE_ACTION_FISHEYE_DISABLED, this);
	action->setCheckable(true);
	action->setChecked(true);
	actionGroupFisheye.addAction(action);
	action = new QAction(NODE_ACTION_FISHEYE_NORMAL, this);
	action->setCheckable(true);
	actionGroupFisheye.addAction(action);
	action = new QAction(NODE_ACTION_FISHEYE_NORMAL_SUBTLE, this);
	action->setCheckable(true);
	actionGroupFisheye.addAction(action);
	action = new QAction(NODE_ACTION_FISHEYE_LARGE, this);
	action->setCheckable(true);
	actionGroupFisheye.addAction(action);
	action = new QAction(NODE_ACTION_FISHEYE_LARGE_SUBTLE, this);
	action->setCheckable(true);
	actionGroupFisheye.addAction(action);
	m_fisheye_view_sub_menu->addActions(actionGroupFisheye.actions());

	m_context_menu->addAction(new QAction(NODE_ACTION_SELECTED_TO_COMPOUND, this));
	m_context_menu->addAction(new QAction(NODE_ACTION_COLLAPSE_ALL, this));
	m_context_menu->addAction(new QAction(NODE_ACTION_EXPAND_ALL, this));
	m_context_menu->addAction(new QAction(NODE_ACTION_EXPAND_COMPOUNDS, this));
	m_context_menu->addAction(new QAction(NODE_ACTION_CENTER, this));
	m_context_menu->addAction(new QAction(NODE_ENTER_OBJECT, this));

	setMenuZoomEnabled(true);
	setMenuSelectionToCompoundEnabled(true);
	setMenuCollapseExpandEnabled(true);
	setMenuExpandCompoundsEnabled(true);
	setMenuFisheyeViewEnabled(true);
	setContextMenuPolicy(Qt::CustomContextMenu);
	connect(m_context_menu, SIGNAL(triggered(QAction*)), this, SLOT(contextMenuItemSelected(QAction*)));
	setLayout(mainLayout);
}

QtNodeEditor::~QtNodeEditor()
{
	delete m_scene_scene;
}

//****************************************************************************/
void QtNodeEditor::setContextMenuEnabled(bool enabled)
{
	m_context_menu_enabled = enabled;
}

//****************************************************************************/
void QtNodeEditor::setCompoundHeaderTitleIcon(const QString &fileNameIcon)
{
	m_header_title_icon = fileNameIcon;
}

//****************************************************************************/
void QtNodeEditor::setCompoundAction1Icon(const QString &fileNameIcon)
{
	m_action_1_icon = fileNameIcon;
}

//****************************************************************************/
void QtNodeEditor::setCompoundAction2Icon(const QString &fileNameIcon)
{
	m_action_2_icon = fileNameIcon;
}

//****************************************************************************/
bool QtNodeEditor::isContextMenuEnabled()
{
	return m_context_menu_enabled;
}

//****************************************************************************/
void QtNodeEditor::setMenuZoomEnabled(bool enabled)
{
	m_menu_zoom_enabled = enabled;
	QAction *action = getActionFromContextMenu(NODE_ACTION_ZOOM);
	if (action)
		action->setVisible(enabled);
}

//****************************************************************************/
bool QtNodeEditor::isMenuZoomEnabled()
{
	return m_menu_zoom_enabled;
}

//****************************************************************************/
void QtNodeEditor::setMenuSelectionToCompoundEnabled(bool enabled)
{
	m_menu_selection_to_compound_enabled = enabled;
	QAction *action = getActionFromContextMenu(NODE_ACTION_SELECTED_TO_COMPOUND);
	if (action)
		action->setVisible(enabled);
}

//****************************************************************************/
bool QtNodeEditor::isMenuSelectionToCompoundEnabled()
{
	return m_menu_selection_to_compound_enabled;
}

//****************************************************************************/
void QtNodeEditor::setMenuCollapseExpandEnabled(bool enabled)
{
	m_menu_collapse_expand_enabled = enabled;
	QAction *action = getActionFromContextMenu(NODE_ACTION_EXPAND_ALL);
	if (action)
		action->setVisible(enabled);
	action = getActionFromContextMenu(NODE_ACTION_COLLAPSE_ALL);
	if (action)
		action->setVisible(enabled);
}

//****************************************************************************/
bool QtNodeEditor::isMenuCollapseExpandEnabled()
{
	return m_menu_collapse_expand_enabled;
}

//****************************************************************************/
void QtNodeEditor::setMenuExpandCompoundsEnabled(bool enabled)
{
	m_menu_expand_compounds_enabled = enabled;
	QAction *action = getActionFromContextMenu(NODE_ACTION_EXPAND_COMPOUNDS);
	if (action)
		action->setVisible(enabled);
}

//****************************************************************************/
bool QtNodeEditor::isMenuExpandCompoundsEnabled()
{
	return m_menu_expand_compounds_enabled;
}

//****************************************************************************/
void QtNodeEditor::setMenuFisheyeViewEnabled(bool enabled)
{
	m_menu_fisheye_view_enabled = enabled;
	QAction *action = getActionFromContextMenu(NODE_ACTION_FISHEY_VIEW);
	if (action)
		action->setVisible(enabled);
}

//****************************************************************************/
bool QtNodeEditor::isMenuFisheyeViewEnabled()
{
	return m_menu_fisheye_view_enabled;
}

//****************************************************************************/
void QtNodeEditor::setFisheyeView(bool enabled, qreal maxZoom, unsigned int steps)
{
	m_fisheye_view_enabled = enabled;
	m_fisheye_max_zoom = maxZoom;
	m_fisheye_steps = steps;
}

//****************************************************************************/
QGraphicsItem *QtNodeEditor::itemAtExceptActiveConnection(const QPointF &pos)
{
	QList<QGraphicsItem*> items = m_current_scene->items(QRectF(pos - QPointF(1,1), QSize(3,3)));
	bool isActive = isActiveConnection();

	for (QGraphicsItem *item : items) {
		/* If there is an active connection, it is not returned as a selected item */
		/* Finalized (established) connections are returned */
		if (item->isVisible()) {
			if (isConnection(item)) {
				if (!isActive)
					return item;
			}
			else
				return item;
		}
	}

	return nullptr;
}

//****************************************************************************/
QtCompoundNode *QtNodeEditor::nodeOverCompound(QtNode *node)
{
	if (!node) {
		return nullptr;
	}

	QtCompoundNode *compound;
	qreal halfWidth;

	for (QGraphicsItem *item : m_current_scene->items()) {
		if (!isCompoundNode(item) || !item->isVisible()) {
			continue;
		}

		compound = static_cast<QtCompoundNode *>(item);

		if (node == compound || compound->isSelected()) {
			continue;
		}

		halfWidth = 0.5 * compound->getWidth();

		if (node->scenePos().x() > compound->scenePos().x() - halfWidth &&
		    node->scenePos().x() < compound->scenePos().x() + halfWidth &&
		    node->scenePos().y() > compound->scenePos().y() &&
		    node->scenePos().y() < compound->scenePos().y() + compound->getHeigth())
		{
			return compound;
		}
	}

	return nullptr;
}

//****************************************************************************/
bool QtNodeEditor::eventFilter(QObject *object, QEvent *event)
{
	auto mouseEvent = static_cast<QGraphicsSceneMouseEvent *>(event);

	switch ((int) event->type()) {
		case QEvent::GraphicsSceneMousePress:
			mouseClickHandler(mouseEvent);
			break;
		case QEvent::GraphicsSceneMouseDoubleClick:
			mouseDoubleClickHandler(mouseEvent);
			break;
		case QEvent::GraphicsSceneMouseMove:
			mouseMoveHandler(mouseEvent);
			break;
		case QEvent::GraphicsSceneMouseRelease:
			mouseReleaseHandler(mouseEvent);
			break;
	}

	return QObject::eventFilter(object, event);
}

//****************************************************************************/
bool QtNodeEditor::mouseClickHandler(QGraphicsSceneMouseEvent *mouseEvent)
{
	switch ((int) mouseEvent->button()) {
		case Qt::LeftButton:
		{
			QGraphicsItem *item = itemAtExceptActiveConnection(mouseEvent->scenePos());
			if (!item) {
				/* Left-click on the canvas, but no item clicked, so deselect nodes and connections */
				deselectAll();
				m_rubberband_selection = true;
				m_last_mouse_position.setX(mouseEvent->lastScenePos().x());
				m_last_mouse_position.setY(mouseEvent->lastScenePos().y());
				return true;
			}

			m_rubberband_selection = false;

			/* Delegate to the node; either the node itself is clicked, one of its children or a connection */
			if (item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).isValid()) {
				int type = item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).toInt();
				QtNode *node;

				if (NODE_VALUE_TYPE_CONNECTION == type) {
					/* ======================= Handle selected connection ======================= */
					QtConnection *connection = static_cast<QtConnection*>(item);
					selectConnection(connection);
				}
				else if (NODE_VALUE_TYPE_NODE == type) {
					/* ======================= The node itself is clicked ======================= */
					node = static_cast<QtNode*>(item);
					selectNode(node, mouseEvent);
				}
				else if (NODE_VALUE_TYPE_HEADER_ICON == type || NODE_VALUE_TYPE_HEADER_TITLE == type) {
					/* ======================= The header title or header icon is clicked ======================= */
					node = static_cast<QtNode*>(item->parentItem());
					selectNode(node, mouseEvent);
				}
				else {
					/* A child item of the node is clicked */
					deselectNodes();
					deselectConnections();
					node = static_cast<QtNode*>(item->parentItem());

					if (NODE_VALUE_TYPE_PORT == type) {
						/* ======================= Port is clicked ======================= */
						/* Either make a connection to another port, or create a new connection */
						QtNode *baseNode = getNodeWithActiveConnection();
						if (baseNode == nullptr) {
							/* There is no active connection, so start one */
							node->mouseLeftClickHandler(mouseEvent, item, NODE_ACTION_BASE);
							setCursor(Qt::ClosedHandCursor);
						}
						else if (baseNode != node) {
							/* There is an active connection and the selected port is not part of the baseNode, */
							/* so try to establish a connection with the other node */
							if (node->mouseLeftClickHandler(mouseEvent, item, NODE_ACTION_TARGET, baseNode->m_active_connection))
							{
								/* The connection was established, so the active connection on the basenode can be set to 0 */
								baseNode->m_active_connection = nullptr;
								setCursor(Qt::ArrowCursor);
							}
						}
					}
					else {
						node->mouseLeftClickHandler(mouseEvent, item); /* Don't do anything with the node after this; it may be deleted */
					}
				}
				return true;
			}
		}
			break;

		case Qt::RightButton:
		{
			if (m_context_menu_enabled) {
				QPoint pos;
				pos.setX(mouseEvent->lastScreenPos().x());
				pos.setY(mouseEvent->lastScreenPos().y());
				showContextMenu(pos);
			}
			else
				deselectAll();

			return true;
		}
			break;
	}

	//mouseEvent->accept();
	return true;
}

//****************************************************************************/
bool QtNodeEditor::mouseDoubleClickHandler(QGraphicsSceneMouseEvent *mouseEvent)
{
	Q_UNUSED(mouseEvent);
	/* todo */
	return true;
}

//****************************************************************************/
bool QtNodeEditor::mouseMoveHandler(QGraphicsSceneMouseEvent *mouseEvent)
{
	/* If a Fisheye view is enabled, apply it */
	if (m_fisheye_view_enabled) {
		fisheyeZoom(mouseEvent);
	}

	/* If there was a rubberband selection started, update its rectangle */
	if (m_rubberband_selection && (mouseEvent->buttons() & Qt::LeftButton)) {
		/* Rubberband selection */
		rubberbandSelection(mouseEvent);
	}

	QtNode *node;

	for (QGraphicsItem *item : m_current_scene->items()) {
		if (!isNode(item) || !item->isVisible()) {
			continue;
		}

		node = static_cast<QtNode *>(item);
		node->mouseMoveHandler(mouseEvent, item);

		/* Only perform drag and drop of a node on a compound when the node is selected */
		if (!node->isSelected() || !(mouseEvent->buttons() & Qt::LeftButton)) {
			continue;
		}

		QtCompoundNode *compound = nodeOverCompound(node);

		if (compound) {
			setCursor(Qt::CrossCursor); /* Indication that the node(s) can be dropped */
			m_compound_node_dropped = compound;
			return true;
		}
	}

	m_compound_node_dropped = nullptr;
	setCursor(Qt::ArrowCursor);
	return true;
}

//****************************************************************************/
bool QtNodeEditor::mouseReleaseHandler(QGraphicsSceneMouseEvent *mouseEvent)
{
	/* Determine whether one or more nodes are dropped on a compound */
	if (m_compound_node_dropped) {
		/* Add node(s) to the compound */
		for (QtNode *node : m_currently_selected_nodes) {
			m_compound_node_dropped->addNode(node);
		}

		deselectAll();
		m_compound_node_dropped = nullptr;
		return true;
	}

	/* Handle the rubberband selection, if applicable */
	if (!m_rubberband_selection)
		return false;

	if (mouseEvent->button() & Qt::LeftButton) {
		if (m_rubber_band) {
			qreal minX = qMin(m_last_mouse_position.x(), mouseEvent->lastScenePos().x());
			qreal maxX = qMax(m_last_mouse_position.x(), mouseEvent->lastScenePos().x());
			qreal minY = qMin(m_last_mouse_position.y(), mouseEvent->lastScenePos().y());
			qreal maxY = qMax(m_last_mouse_position.y(), mouseEvent->lastScenePos().y());
			qreal item_Min_X;
			qreal item_Max_X;
			qreal item_Min_Y;
			qreal item_Max_Y;

			/* Select the items */
			QList<QGraphicsItem*> items = m_current_scene->items();
			QtNode *node;
			QtConnection *connection;
			for (QGraphicsItem *item : items) {
				if (isConnection(item) && item->isVisible()) {
					connection = static_cast<QtConnection *>(item);
					if (connection->getBasePort() && connection->getTargetPort()) {
						item_Min_X = qMin(connection->getBasePort()->scenePos().x(), connection->getTargetPort()->scenePos().x());
						item_Max_X = qMax(connection->getBasePort()->scenePos().x(), connection->getTargetPort()->scenePos().x());
						item_Min_Y = qMin(connection->getBasePort()->scenePos().y(), connection->getTargetPort()->scenePos().y());
						item_Max_Y = qMax(connection->getBasePort()->scenePos().y(), connection->getTargetPort()->scenePos().y());
						if (item_Min_X > minX && item_Max_X < maxX && item_Min_Y > minY && item_Max_Y < maxY)
						{
							connection->setSelected(true);
							if (!isConnectionAlreadySelected(connection))
								m_currently_selected_connections.append(connection);
						}
					}
				}
				else if (isNode(item) && item->isVisible()) {
					node = static_cast<QtNode*>(item);
					item_Min_X = node->scenePos().x() - 0.5 * node->sceneBoundingRect().width() + 10;
					item_Min_Y = node->scenePos().y() - 0.5 * node->sceneBoundingRect().height() + 10;
					item_Max_X = item_Min_X + node->sceneBoundingRect().width() + 10;
					item_Max_Y = item_Min_Y + node->sceneBoundingRect().height()  + 10;
					if (item_Min_X > minX && item_Max_X < maxX && item_Min_Y > minY && item_Max_Y < maxY)
					{
						node->setSelected(true);
						if (!isNodeAlreadySelected(node))
							m_currently_selected_nodes.append(node);

						/* TODO(kevin): this is weak */
						if (m_editor_mode == EDITOR_MODE_SCENE) {
							Q_EMIT objectNodeSelected(static_cast<ObjectNodeItem *>(node));
						}
						else {
							Q_EMIT nodeSelected(node);
						}

						toFront(node);
					}
				}
			}

			m_rubber_band->hide();
		}

		m_rubberband_selection = false;
	}

	return true;
}

//****************************************************************************/
void QtNodeEditor::keyPressEvent(QKeyEvent *event)
{
	if (event->key() == Qt::Key_Delete) {
		/* Delete all selected connections first */
		QtPort *basePort;
		QtNode *baseNode;
		for (QtConnection *selectedConnection : m_currently_selected_connections) {
			/* Delete the connection */
			if (selectedConnection) {
				basePort = selectedConnection->getBasePort();

				if (basePort) {
					baseNode = static_cast<QtNode*>(basePort->parentItem());

					if (baseNode)
						baseNode->_emitConnectionDeleted(basePort);
				}

				removeConnection(selectedConnection);
			}
		}

		m_currently_selected_connections.clear();

		/* Delete all selected nodes */
		for (QtNode *selectedNode : m_currently_selected_nodes) {
			/* Delete the node */
			removeNode(selectedNode);
			//delete selectedNode;
		}

		m_currently_selected_nodes.clear();
	}
}

//****************************************************************************/
void QtNodeEditor::fisheyeZoom(QGraphicsSceneMouseEvent *mouseEvent)
{
	QPointF a = m_view->mapToScene(0, 0);
	QPointF b = m_view->mapToScene(m_view->viewport()->width(), m_view->viewport()->height());
	qreal x0 = a.x();
	qreal y0 = a.y();
	qreal x1 = b.x();
	qreal y1 = b.y();
	qreal width = x1 - x0;
	qreal height = y1 - y0;
	qreal widthPadding = 0.0f;
	qreal heightPadding = 0.0f;
	qreal fraction;
	qreal zoom = m_zoom;
	qreal zoomStep = (m_fisheye_max_zoom - m_zoom) / m_fisheye_steps;
	QtNode *node;
	QPointF pos = mouseEvent->scenePos();

	QList<QGraphicsItem *> items;

	for (unsigned int i = 2; i <= m_fisheye_steps; ++i) {
		items = m_current_scene->items(QRectF(pos - QPointF(0.5 * width, 0.5 * height), QSize(width, height)));

		for (QGraphicsItem *item : items) {
			if (isNode(item)) {
				node = static_cast<QtNode*>(item);
				node->setZoom(zoom);
				widthPadding = 0.5 * node->getWidth();
				heightPadding = node->getHeigth();
			}
		}

		zoom += zoomStep;
		fraction = 1.0f - (qreal)i / m_fisheye_steps;
		width = fraction * width + widthPadding;
		height = fraction * height + heightPadding;
		items.clear();
	}

	m_current_scene->update();
}

//****************************************************************************/
void QtNodeEditor::rubberbandSelection(QGraphicsSceneMouseEvent *mouseEvent)
{
	/* Mouse is pressed and moves => draw rubberband */
	qreal x = mouseEvent->lastScenePos().x();
	qreal y = mouseEvent->lastScenePos().y();

	if (!m_rubber_band) {
		m_rubber_band = new QGraphicsRectItem(m_last_mouse_position.x(), m_last_mouse_position.y(), 0.0f, 0.0f);
		m_rubber_band->setPen(QPen(Qt::darkBlue));
		QColor c(Qt::darkBlue);
		c.setAlpha(64);
		m_rubber_band->setBrush(c);
		m_current_scene->addItem(m_rubber_band);
	}

	m_rubber_band->show();
	qreal minX = qMin((qreal)m_last_mouse_position.x(), x);
	qreal maxX = qMax((qreal)m_last_mouse_position.x(), x);
	qreal minY = qMin((qreal)m_last_mouse_position.y(), y);
	qreal maxY = qMax((qreal)m_last_mouse_position.y(), y);
	m_rubber_band->setRect(minX, minY, maxX - minX, maxY - minY);
}

//****************************************************************************/
void QtNodeEditor::selectNode(QtNode *node, QGraphicsSceneMouseEvent *mouseEvent)
{
	node->mouseLeftClickHandler(mouseEvent, node);  /* pass the node itself also, because this function is also */
	/* used for other purposes than selecting the node itself */
	if (!ctrlPressed()) {
		deselectAll();
		m_currently_selected_nodes.append(node);
	}
	else if (!isNodeAlreadySelected(node)) {
		m_currently_selected_nodes.append(node);
		/* Do not call setSelection on the node; the node is selectable, while the connection isn't */
	}

	/* TODO(kevin): this is weak */
	if (m_editor_mode == EDITOR_MODE_SCENE) {
		Q_EMIT objectNodeSelected(static_cast<ObjectNodeItem *>(node));
	}
	else {
		Q_EMIT nodeSelected(node);
	}

	node->_emitNodeSelected(); /* Causes a signal to Q_EMIT */
	toFront(node);
}

//****************************************************************************/
void QtNodeEditor::selectConnection(QtConnection *connection)
{
	if (!ctrlPressed()) {
		deselectAll();
		m_currently_selected_connections.append(connection);
		connection->setSelected(true);
	}
	else if (!isConnectionAlreadySelected(connection)) {
		m_currently_selected_connections.append(connection);
		connection->setSelected(true);
	}
}

//****************************************************************************/
void QtNodeEditor::deselectAll()
{
	setCursor(Qt::ArrowCursor);
	deleteAllActiveConnections();
	deselectConnections();
	deselectNodes();
}

//****************************************************************************/
void QtNodeEditor::deleteAllActiveConnections()
{
	QtNode *node;
	QList<QGraphicsItem*> items = m_current_scene->items();

	for (QGraphicsItem *item : items) {
		if (isNode(item) && item->isVisible()) {
			node = static_cast<QtNode *>(item);
			node->deleteActiveConnection();
		}
	}
}

//****************************************************************************/
bool QtNodeEditor::isActiveConnection()
{
	QtNode *node;
	QList<QGraphicsItem*> items = m_current_scene->items();

	for (QGraphicsItem *item : items) {
		if (isNode(item) && item->isVisible()) {
			node = static_cast<QtNode *>(item);
			if (node->m_active_connection)
				return true;
		}
	}
	return false;
}

//****************************************************************************/
void QtNodeEditor::deselectConnections()
{
	for (QtConnection *connection : m_currently_selected_connections) {
		if (connection->isVisible()) {
			connection->setSelected(false);
		}
	}

	m_currently_selected_connections.clear();
}

//****************************************************************************/
void QtNodeEditor::deselectNodes()
{
	for (QtNode *node : m_currently_selected_nodes) {
		if (node->isVisible()) {
			node->setSelected(false);
		}
	}

	m_currently_selected_nodes.clear();
}

//****************************************************************************/
QtNode *QtNodeEditor::getNodeWithActiveConnection()
{
	QtNode *node;
	QList<QGraphicsItem*> items = m_current_scene->items();

	for (QGraphicsItem *item : items) {
		if (isNode(item) && item->isVisible()) {
			node = static_cast<QtNode*>(item);
			if (node->m_active_connection)
				return node;
		}
	}

	return nullptr;
}

//****************************************************************************/
void QtNodeEditor::addNode(QtNode *node)
{
	node->_setEditor(this);
	node->_setScene(m_current_scene);
	m_current_scene->addItem(node);
	node->setZoom(m_zoom);
	Q_EMIT nodeAdded(node);
}

//****************************************************************************/
QVector<QtNode *> QtNodeEditor::getNodes() const
{
	QVector<QtNode *> nodeList;
	QtNode *node;
	QList<QGraphicsItem*> items = m_current_scene->items();
	for (QGraphicsItem *item : items) {
		if (isNode(item) && item->isVisible()) {
			node = static_cast<QtNode*>(item);
			nodeList.append(node);
		}
	}

	return nodeList;
}

//****************************************************************************/
void QtNodeEditor::removeNode(QtNode *node, bool cascade)
{
	if (!node) {
		return;
	}

	QVector<QtNode*> nodes;
	m_last_removed_node = node;

	if (cascade && isCompoundNode(node)) {
		nodes = getNodes();
	}

	node->_prepareDelete();
	if (m_editor_mode == EDITOR_MODE_SCENE) {
		Q_EMIT objectNodeRemoved(static_cast<ObjectNodeItem *>(node));
	}
	else {
		Q_EMIT nodeToBeRemoved(node);
	}

	m_current_scene->removeItem(node);

	delete node;

	/* Check the released nodes (if needed) */
	if (!nodes.isEmpty()) {
		for (QtNode *releaseNode : nodes) {
			if (isCompoundNode(releaseNode)) {
				removeNode(releaseNode, cascade);
			}
		}
	}
}

//****************************************************************************/
void QtNodeEditor::removeConnection(QtConnection *connection)
{
	if (!connection) {
		return;
	}

	QtPort *base_port = connection->getBasePort();

	if (!base_port) {
		return;
	}

	QtPort *target_port = connection->getTargetPort();

	/* Connections of a compound node may not be removed. A compound node is the
	 * only one that has connections were base- and targetports belong to the
	 * same parent item. */
	if (base_port->parentItem() == target_port->parentItem()) {
		return;
	}

	auto base_name = base_port->getPortName();
	auto target_name = target_port->getPortName();

	auto base_node = static_cast<QtNode *>(base_port->parentItem());
	auto target_node = static_cast<QtNode *>(target_port->parentItem());

	Q_EMIT connectionRemoved(base_node, base_name, target_node, target_name);

	m_current_scene->removeItem(connection);

	base_port->deleteConnection();
}

//****************************************************************************/
void QtNodeEditor::removeAllSelelected()
{
	for (QtConnection *selectedConnection : m_currently_selected_connections) {
		removeConnection(selectedConnection);
	}

	m_currently_selected_connections.clear();

	for (QtNode *selectedNode : m_currently_selected_nodes) {
		removeNode(selectedNode);
	}

	m_currently_selected_nodes.clear();
}

//****************************************************************************/
void QtNodeEditor::center()
{
	QList<QGraphicsItem*> items = m_current_scene->items();
	for (QGraphicsItem *item : items) {
		if (isNode(item)) {
			item->setPos(0, 0);
		}
	}
}

//****************************************************************************/
void QtNodeEditor::clear()
{
	m_current_scene->clear(); /* removes + deletes all items in the scene */
}

//****************************************************************************/
QtNode *QtNodeEditor::getLastSelectedNode() const
{
	if (m_currently_selected_nodes.empty()) {
		return nullptr;
	}

	return m_currently_selected_nodes.at(m_currently_selected_nodes.count() - 1);
}

//****************************************************************************/
const QVector<QtNode *> &QtNodeEditor::getSelectedNodes() const
{
	return m_currently_selected_nodes;
}

//****************************************************************************/
const QVector<QtConnection *> &QtNodeEditor::getSelectedConnections() const
{
	return m_currently_selected_connections;
}

//****************************************************************************/
QtNode *QtNodeEditor::getRemovedNode()
{
	return m_last_removed_node;
}

//****************************************************************************/
void QtNodeEditor::toFront(QtNode *node)
{
	if (!node) {
		return;
	}

	QList<QGraphicsItem *> items = m_current_scene->items();

	/* First set the node in front of all other nodes */
	for (QGraphicsItem *item : items) {
		if (node != item && isNode(item) && item->isVisible()) {
			item->stackBefore(node);
		}
	}

	/* Put the connections of the node in front of the node and the other connections behind the node */
	for (QGraphicsItem *item : items) {
		if (!isNode(item)) {
			continue;
		}

		QtConnection *connection = static_cast<QtConnection *>(item);

		if (node->isConnectionConnectedToThisNode(connection)) {
			node->stackBefore(item);
		}
		else {
			item->stackBefore(node);
		}
	}
}

//****************************************************************************/
void QtNodeEditor::toBack(QtNode *node)
{
	if (!node)
		return;

	QList<QGraphicsItem*> items = m_current_scene->items();

	/* Set all other nodes in front of this node */
	for (QGraphicsItem *item : items) {
		if (node != item && isNode(item) && item->isVisible()) {
			node->stackBefore(item);
		}
	}
}

//****************************************************************************/
void QtNodeEditor::setZoom(qreal zoom)
{
	m_zoom = zoom;
	QtNode *node;
	QList<QGraphicsItem*> items = m_current_scene->items();

	for (QGraphicsItem *item : items) {
		if (isNode(item) && item->isVisible()) {
			node = static_cast<QtNode *>(item);
			node->setZoom(zoom);
		}
	}
}

//****************************************************************************/
bool QtNodeEditor::ctrlPressed()
{
	return (QGuiApplication::keyboardModifiers() & Qt::ControlModifier);
}

//****************************************************************************/
bool QtNodeEditor::isNodeAlreadySelected(QtNode *node)
{
	auto iter = std::find(m_currently_selected_nodes.begin(),
	                      m_currently_selected_nodes.end(),
	                      node);

	return (iter != m_currently_selected_nodes.end());
}

//****************************************************************************/
bool QtNodeEditor::isConnectionAlreadySelected(QtConnection *connection)
{
	auto iter = std::find(m_currently_selected_connections.begin(),
	                      m_currently_selected_connections.end(),
	                      connection);

	return (iter != m_currently_selected_connections.end());
}

//****************************************************************************/
void QtNodeEditor::showContextMenu(const QPoint &pos)
{
	if (!m_context_menu) {
		return;
	}

	QList<QAction *> actions = m_context_menu->actions();
	const bool nodesSelected = !m_currently_selected_nodes.isEmpty();
	const bool itemsSelected = nodesSelected || !m_currently_selected_connections.isEmpty();

	QFont font;
	/* Italic when no selected items available */
	font.setItalic(!itemsSelected);

	for (auto &action : actions) {
		if (action->text() == NODE_ACTION_DELETE) {
			action->setFont(font);
			action->setEnabled(itemsSelected);
		}

		if (action->text() == NODE_ACTION_SELECTED_TO_COMPOUND || action->text() == NODE_ENTER_OBJECT) {
			action->setFont(font);
			action->setEnabled(nodesSelected);
		}
	}

	m_context_menu->popup(pos);
}

//****************************************************************************/
QAction *QtNodeEditor::getActionFromContextMenu(const QString &actionText)
{
	if (!m_context_menu) {
		return nullptr;
	}

	QList<QAction*> actions = m_context_menu->actions();
	for (QAction *action : actions) {
		if (action->text() == actionText) {
			return action;
		}
	}

	return nullptr;
}

//****************************************************************************/
void QtNodeEditor::setZoom_For_Action(qreal zoom, QAction *action)
{
	setZoom(zoom);
	resetZoomSubmenu();
	action->setChecked(true);
}

//****************************************************************************/
void QtNodeEditor::resetZoomSubmenu()
{
	QList<QAction*> actions = m_zoom_sub_menu->actions();
	for (QAction *action : actions)
		action->setChecked(false);
}

//****************************************************************************/
void QtNodeEditor::setFisheyeForAction(QAction *action, bool enabled, qreal maxZoom, unsigned int steps)
{
	setFisheyeView(enabled, maxZoom, steps);
	resetFisheySubmenu();
	action->setChecked(true);
}

//****************************************************************************/
void QtNodeEditor::resetFisheySubmenu()
{
	QList<QAction*> actions = m_fisheye_view_sub_menu->actions();
	for (QAction *action : actions)
		action->setChecked(false);
}

//****************************************************************************/
void QtNodeEditor::contextMenuItemSelected(QAction *action)
{
	/* ---------------- Delete action ---------------- */
	if (action->text() == NODE_ACTION_DELETE) {
		/* Delete the selected nodes and connections from the scene */
		removeAllSelelected();
		return;
	}

	/* ---------------- Center action ---------------- */
	if (action->text() == NODE_ACTION_CENTER) {
		/* Center all nodes */
		center();
		return;
	}

	/* ---------------- Zoom action ---------------- */
	if (action->text() == NODE_ACTION_ZOOM_10) {
		setZoom_For_Action(0.1f, action);
		return;
	}

	if (action->text() == NODE_ACTION_ZOOM_25) {
		setZoom_For_Action(0.25f, action);
		return;
	}

	if (action->text() == NODE_ACTION_ZOOM_50) {
		setZoom_For_Action(0.5f, action);
		return;
	}

	if (action->text() == NODE_ACTION_ZOOM_75) {
		setZoom_For_Action(0.75f, action);
		return;
	}

	if (action->text() == NODE_ACTION_ZOOM_90) {
		setZoom_For_Action(0.9f, action);
		return;
	}

	if (action->text() == NODE_ACTION_ZOOM_100) {
		setZoom_For_Action(1.0f, action);
		return;
	}

	if (action->text() == NODE_ACTION_ZOOM_150) {
		setZoom_For_Action(1.5f, action);
		return;
	}

	if (action->text() == NODE_ACTION_ZOOM_200) {
		setZoom_For_Action(2.0f, action);
		return;
	}

	if (action->text() == NODE_ACTION_ZOOM_250) {
		setZoom_For_Action(2.5f, action);
		return;
	}

	if (action->text() == NODE_ACTION_ZOOM_300) {
		setZoom_For_Action(3.0f, action);
		return;
	}

	if (action->text() == NODE_ACTION_ZOOM_10) {
		setZoom_For_Action(0.1f, action);
		return;
	}

	/* ---------------- Fisheye action ---------------- */
	if (action->text() == NODE_ACTION_FISHEYE_DISABLED) {
		setFisheyeForAction(action, false);
		return;
	}

	if (action->text() == NODE_ACTION_FISHEYE_NORMAL) {
		setFisheyeForAction(action, true, 1.4f);
		return;
	}

	if (action->text() == NODE_ACTION_FISHEYE_NORMAL_SUBTLE) {
		setFisheyeForAction(action, true, 1.1f, 10);
		return;
	}

	if (action->text() == NODE_ACTION_FISHEYE_LARGE) {
		setFisheyeForAction(action, true, 1.7f);
		return;
	}

	if (action->text() == NODE_ACTION_FISHEYE_LARGE_SUBTLE) {
		setFisheyeForAction(action, true, 1.5f, 10);
		return;
	}

	/* ---------------- To compound action ---------------- */
	if (action->text() == NODE_ACTION_SELECTED_TO_COMPOUND) {
		/* Add the selected nodes to a compound */
		QtCompoundNode *compound = new QtCompoundNode("Compound");
		compound->setTitleColor(Qt::white);
		compound->setHeaderTitleIcon(m_header_title_icon);
		compound->setAction1Icon(m_action_1_icon);
		compound->setAction2Icon(m_action_2_icon);
		compound->alignTitle(ALIGNED_LEFT);
		compound->setHeaderColor(QColor("#888888"));
		compound->setAutoSize(true);
		Q_EMIT selectedNodesToBeAddedToCompound(); /* First Q_EMIT the signal before the nodes are added to the compound */

		for (QtNode *node : m_currently_selected_nodes) {
			compound->addNode(node);
			compound->setPos(node->pos());
		}

		addNode(compound);
		m_currently_selected_nodes.clear();
		return;
	}

	/* ---------------- Collapse action ---------------- */
	if (action->text() == NODE_ACTION_COLLAPSE_ALL) {
		QtNode *node;
		QList<QGraphicsItem*> items = m_current_scene->items();

		for (QGraphicsItem *item : items) {
			if (isNode(item) && item->isVisible()) {
				node = static_cast<QtNode*>(item);
				node->collapse();
			}
		}

		return;
	}

	/* ---------------- Expand action ---------------- */
	if (action->text() == NODE_ACTION_EXPAND_ALL) {
		QtNode *node;
		QList<QGraphicsItem*> items = m_current_scene->items();

		for (QGraphicsItem *item : items) {
			if (isNode(item) && item->isVisible()) {
				node = static_cast<QtNode *>(item);
				node->expand();
			}
		}

		return;
	}

	/* ---------------- Enter object action ---------------- */
	if (action->text() == NODE_ENTER_OBJECT) {
		auto node = static_cast<ObjectNodeItem *>(m_currently_selected_nodes.back());
		m_current_scene = node->nodeScene();
		m_current_scene->installEventFilter(this);
		m_editor_mode = EDITOR_MODE_OBJECT;
		m_view->setScene(m_current_scene);

		action->setText(NODE_EXIT_OBJECT);

		return;
	}

	/* ---------------- Exit object action ---------------- */
	if (action->text() == NODE_EXIT_OBJECT) {
		m_current_scene = m_scene_scene;
		m_view->setScene(m_current_scene);

		action->setText(NODE_ENTER_OBJECT);

		return;
	}

	/* ---------------- Expand compounds action ---------------- */
	if (action->text() == NODE_ACTION_EXPAND_COMPOUNDS) {
		QtCompoundNode *compound;
		QList<QGraphicsItem*> items = m_current_scene->items();

		for (QGraphicsItem *item : items) {
			if (isCompoundNode(item) && item->isVisible()) {
				compound = static_cast<QtCompoundNode*>(item);
				removeNode(compound, true);
			}
		}

		return;
	}
}

inline bool is_input_port(QtPort *port)
{
	return port->getPortType().m_port_type == NODE_PORT_TYPE_INPUT;
}

void QtNodeEditor::connectionEstablished(QtNode *node, QtPort *port, QtConnection *connection)
{
	Q_UNUSED(node);
	Q_UNUSED(port);

	auto base_port = connection->getBasePort();
	auto target_port = connection->getTargetPort();

	/* make sure the connection is done in the right order */
	if (!is_input_port(target_port) && is_input_port(base_port)) {
		std::swap(base_port, target_port);
	}

	auto base_name = base_port->getPortName();
	auto target_name = target_port->getPortName();

	auto base_node = static_cast<QtNode *>(base_port->parentItem());
	auto target_node = static_cast<QtNode *>(target_port->parentItem());

	Q_EMIT nodesConnected(base_node, base_name, target_node, target_name);
}

//****************************************************************************/
bool QtNodeEditor::isNode(QGraphicsItem *item) const
{
	if (item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).isValid()) {
		int type = item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).toInt();
		return NODE_VALUE_TYPE_NODE == type;
	}

	return false;
}

//****************************************************************************/
bool QtNodeEditor::isCompoundNode(QGraphicsItem *item)
{
	if (item->data(NODE_KEY_GRAPHIC_ITEM_SUBTYPE).isValid()) {
		int subType = item->data(NODE_KEY_GRAPHIC_ITEM_SUBTYPE).toInt();
		return NODE_VALUE_SUBTYPE_COMPOUND == subType;
	}

	return false;
}

//****************************************************************************/
bool QtNodeEditor::isConnection(QGraphicsItem *item)
{
	if (item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).isValid()) {
		int type = item->data(NODE_KEY_GRAPHIC_ITEM_TYPE).toInt();
		return NODE_VALUE_TYPE_CONNECTION == type;
	}

	return false;
}

//****************************************************************************/
void QtNodeEditor::wheelEvent (QWheelEvent *event)
{
	if ((event->delta() > 0 && m_zoom < 3.0f) ||
	    (event->delta() < 0 && m_zoom > 0.25f))
		setZoom(m_zoom + 0.001 * event->delta());

	m_current_scene->update();
}
